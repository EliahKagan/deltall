#!/usr/bin/env bash
# SPDX-License-Identifier: 0BSD

set -efuo pipefail

die() {
    printf '%s: error: %s\n' "$0" "$1" >&2
    exit 2
}

# Quit now if this script cannot work at all, regardless of its arguments.
if ((BASH_VERSINFO[0] < 4)); then
    die 'need Bash version 4 or higher'
fi

# Set an option that is unavailable in too-low Bash versions.
shopt -s lastpipe

# Constants that *might* change in major script changes or forks/adaptations.
readonly my_name='chronicall'
readonly outer_manifest='pyproject.toml'
readonly outer_venv=".venv-$my_name"
readonly toxdir=".tox-$my_name"
readonly allfile='__all__.txt'  # Filename used for __all__ content list files.

# Arrange a portable way to reverse text line-by-line.
if command -v tac >/dev/null; then
    # shellcheck disable=SC2120  # It's okay if the caller passes no arguments.
    portable_tac() {
        tac "$@"
    }
else
    # shellcheck disable=SC2120  # It's okay if the caller passes no arguments.
    portable_tac() {
        # Line-by-line reverse. Like tac, but slow, and supports any POSIX
        # system. This is a classic; see https://unix.stackexchange.com/a/9358.
        sed '1!G;h;$!d' "$@"
    }
fi

# Parse command-line arguments.
if (($# < 2 || $# > 4)); then
    printf 'Usage: %s <python> <package> [<module>] [<regex>]\n' "$0" >&2
    exit 2
fi
readonly outer_python="$1"
readonly package="$2"
readonly module="${3:-$2}"
readonly regex="${4:-^}"

readonly helper_comment="# Auto-generated by $my_name for package $package."

# Check for an existing pyproject.toml.
if test -e "$outer_manifest"; then
    if ! head -n1 -- "$outer_manifest" | grep -Fxq "$helper_comment"; then
        die "existing $outer_manifest not by $my_name or not for \"$package\""
    fi
    printf 'A matching %s already exists. It will be used.\n' "$outer_manifest"
else
    # pyproject.toml doesn't exist for the helper package, so create it.
    cat >"$outer_manifest" <<EOF
$helper_comment

[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "$my_name-helper-$package"
version = "0.1.0"
description = "Helper package for $my_name script"
dependencies = ["$package"]
EOF
    printf 'New %s file created.\n' "$outer_manifest"
fi

# Ensure a suitable outer virtual environment directory and tox directory.
for d in "$outer_venv" "$toxdir"; do
    if ! test -d "$d"; then
        mkdir -- "$d"
        printf '*\n' >"$d/.gitignore"
    fi
done

# Create and activate the outer virtual environment.
"$outer_python" -m venv "$outer_venv"
. "$outer_venv/bin/activate"

# Update PyPA packages inside the outer virtual environment.
if python -m pip freeze --all | grep -q '^setuptools=='; then
    python -m pip install --upgrade pip setuptools wheel
else
    python -m pip install --upgrade pip wheel
fi

# Build an array of non-yanked non-prerelease versions of the package that are
# installable with the specified <python> and, if <regex> was passed, match it.
# (This is the key reason we use an outer venv, though we also use it for tox.)
python -m pip index versions "$package" |
    sed -n '/Available versions: /{s///; s/, /\n/gp}' |
    grep -Ee "$regex" |
    portable_tac |
    mapfile -t versions

# Install tox inside the outer virtual environment, if absent.
python -m pip install 'tox>=4,<5'

# Create a tox.ini file with one environment per version of the package.
# FIXME: Handle the "(no __all__)" case, which I removed for debugging.
cat >tox.ini <<EOF
[tox]
requires =
    tox>=4
envlist =
$(
    printf "    %s\n" "${versions[@]}"
)

[testenv]
deps =
$(
    for version in "${versions[@]}"; do
        printf "    %s: %s==%s\n" "$version" "$package" "$version"
    done
)
allowlist_externals =
    sh
setenv =
    PY_SCRIPT = import $module; print(*$module.__all__, sep="\\n")
commands =
    sh -c 'python -c "\$PY_SCRIPT" | LC_COLLATE="C" sort -u >{envdir}/$allfile'
EOF

TOX_WORK_DIR="$toxdir" tox

run_comm() {
    LC_COLLATE='C' comm "$@" | sed 's/^/    /'
}

report() {
    local -ri count="${#versions[@]}"  # Use our global "versions" array.
    local count_phrase

    local -i index
    local old new
    local -a paths

    if ((count == 1)); then
        count_phrase="$count version"
    else
        count_phrase="$count versions"
    fi

    printf '### %s report for %s, %s, checking %s.__all__\n' \
        "$my_name" "$package" "$count_phrase" "$module"

    # Collect output from each environment.
    for ((index = 1; index < count; ++index)); do
        old="${versions[index-1]}" new="${versions[index]}"
        paths=("$toxdir/$old/$allfile" "$toxdir/$new/$allfile")
        printf "\nChanges from %s to %s...\n" "$old" "$new"
        printf "Added:\n"
        run_comm -13 -- "${paths[@]}"
        printf "Removed:\n"
        run_comm -23 -- "${paths[@]}"
    done
}

report | tee report.txt
printf '\nReport generated successfully.\n'
