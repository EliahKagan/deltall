#!/usr/bin/env bash
# SPDX-License-Identifier: 0BSD

set -efuo pipefail

die() {
    printf '%s: error: %s\n' "$0" "$1" >&2
    exit 2
}

if ((BASH_VERSINFO[0] < 4)); then
    die 'need Bash version 4 or higher'
fi

shopt -s lastpipe

# Parse command-line arguments.
if (($# < 2 || $# > 4)); then
    printf 'Usage: %s <python> <package> [<module>] [<regex>]\n' "$0" >&2
    exit 2
fi
readonly python="$1"
readonly package="$2"
readonly module="${3:-$2}"
readonly regex="${4:-^}"

readonly helper_comment="# Auto-generated by chronicall for package $package."

# Check for an existing pyproject.toml.
if test -f pyproject.toml; then
    if ! head -n1 pyproject.toml | grep -Fxq "$helper_comment"; then
        die "existing pyproject.toml not by chronicall or not for \"$package\""
    fi
else
    # pyproject.toml doesn't exist for the helper package, so create it.
    cat > pyproject.toml <<EOF
$helper_comment

[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "chronicall-helper-$package"
version = "0.1.0"
description = "Helper package for chronicall script"
dependencies = ["$package"]
EOF
fi

# Ensure suitable .venv-chronicall and .tox-chronicall directories.
for d in .venv-chronicall .tox-chronicall; do
    if ! test -d "$d"; then
        mkdir -- "$d"
        printf '*\n' >"$d/.gitignore"
    fi
done

# Prepare our own Python virtual environment.
"$python" -m venv .venv-chronicall
. .venv-chronicall/bin/activate
python -m pip install -U pip setuptools wheel
pip install -U 'tox>=4,<5'

portable_tac() {
    # Line-by-line reverse. Like tac, but slow, and supports all POSIX systems.
    # This is a classic; see https://unix.stackexchange.com/a/9358.
    sed '1!G;h;$!d'
}

# Build an array of non-yanked non-prerelease versions of the package that are
# installable with the specified <python> and, if passed, match <regex>.
pip index versions "$package" |
    sed -n '/Available versions: /{s///; s/, /\n/gp}' |
    grep -Ee "$regex" |
    portable_tac |
    mapfile -t versions

# Create a tox.ini file with one environment per version of the package.
cat >tox.ini <<EOF
[tox]
requires =
    tox>=4
envlist =
$(
    printf "    %s\n" "${versions[@]}"
)

[testenv]
deps =
$(
    for version in "${versions[@]}"; do
        printf "    %s: %s==%s\n" "$version" "$package" "$version"
    done
)
allowlist_externals =
    sort
commands =
    python -c 'import $module; print("\\n".join(getattr($module, "__all__", ["(no __all__)"])))' | sort -u >{envdir}/__all__
EOF

TOX_WORK_DIR=.tox-chronicall tox

indented_comm() {
    comm "$@" | sed 's/^/    /'
}

report() {
    local count_phrase
    local -i i
    local -a paths

    if ((${#versions[@]} == 1)); then
        count_phrase="${#versions[@]} version"
    else
        count_phrase="${#versions[@]} versions"
    fi

    printf '### chronicall report for %s, %s, checking %s.__all__\n' \
        "$package" "$count_phrase" "$module"

    # Collect output from each environment.
    for ((i = 0; i < ${#versions[@]}-1; ++i)); do
        paths=(
            ".tox-chronicall/${versions[i]}/__all__"
            ".tox-chronicall/${versions[i+1]}/__all__"
        )
        printf "\nChanges from %s to %s...\n" "${versions[i]}" "${versions[i+1]}"
        printf "Added:\n"
        indented_comm -13 "${paths[@]}"
        printf "Removed:\n"
        indented_comm -23 "${paths[@]}"
    done
}

report | tee report.txt
printf '\nReport generated successfully.\n'
